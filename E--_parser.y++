%{
#include <iostream>
extern int yylex();
extern void yyerror(const char *s);
extern void errMsg(const char *s);
#define prt(x) cout << x << endl;
using namespace std;
%}

%union{
   char* cVal;
   unsigned int uVal;
   double dblVal;
};

/* Operators */

%token TOK_LEX_ERROR TOK_PAT_STAR TOK_PAT_OR TOK_PAT_NOT
%token TOK_PLUS TOK_MINUS TOK_UMINUS TOK_MULT TOK_DIV TOK_MOD 
%token TOK_BITAND TOK_BITOR TOK_BITNOT TOK_BITXOR TOK_SHL TOK_SHR 
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE TOK_AND TOK_OR TOK_NOT 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN

/* Key words */

%token TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token TOK_ULONGNUM TOK_UINTNUM TOK_DOUBLENUM TOK_VOID TOK_STRING TOK_STRCONST 
%token TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token TOK_LONG TOK_TRUE TOK_FALSE TOK_IDENT

/*********************   Precedence and Associativity    ********************/


/**************************************************************************/

%start specification
%%

specification: ifc_decl_star rule_star {
	prt("Spec");
};

ifc_decl_star: /* empty */ {
}
| ifc_decl_star ifc_decl {}
| ifc_decl_star error TOK_SEMICOLON {
	errMsg("Syntax error, expecting a declaration");
}
;

ifc_decl: TOK_SEMICOLON /* Fill in the other rules */ {}
| class_decl {}
| func_decl {}
| event_decl {}
| var_decl {}
;

class_decl: TOK_CLASS TOK_IDENT TOK_SEMICOLON {}
;

func_decl: type TOK_IDENT TOK_LPAREN formal_param_star TOK_RPAREN TOK_SEMICOLON {} /* function without a body */
| type TOK_IDENT TOK_LPAREN formal_param TOK_RPAREN func_body {} /* function with a body, but no ending semicolon */
| type TOK_IDENT TOK_LPAREN formal_param TOK_RPAREN func_body TOK_SEMICOLON {} /* function with a body, and a ending semicolon */
;

type: base_type {}
| type_name {}
;

base_type: basic_type {}
| TOK_UNSIGNED basic_type {} /* TODO  problematic, not all type can be put after unsigned. */
;

basic_type: TOK_VOID {}
| TOK_BOOL {}
| TOK_STRING {}
| TOK_BYTE {}
| TOK_INT {}
| TOK_LONG {}
| TOK_DOUBLE {}
;

type_name: TOK_IDENT {} /* TODO: not sure what does type_name means, a class name, or something else ? */
;

formal_param_star: {} /* empty parameters */
| formal_param_list {}
;

formal_param_list : type TOK_IDENT {}
| formal_param_list TOK_COMMA type TOK_IDENT {}
;

func_body: TOK_LBRACE var_decl_star stmt stmt_star TOK_RBRACE {} /* TODO: let's suppose variable declarations should comes before statements */
;

var_decl_star: /* empty */ {}
| var_decl_star var_decl {}
;

stmt_star: /* empty */ {}
| stmt_star stmt {}
;

event_decl: TOK_EVENT TOK_IDENT TOK_LPAREN formal_param TOK_RPAREN TOK_SEMICOLON {}
; 

var_decl: type var_list TOK_SEMICOLON {}
;

var_list: var_name {}
| var_list TOK_COMMA var_name {}
;

var_name: TOK_IDENT {}
| TOK_IDENT TOK_ASSIGN expr {}
;

/**
 * 09/27/2016 5:14PM
 * To be completed:
 *     expr, stmt, formal_param
 */
expr: TOK_STRCONST {}
| ref_expr {}
| assign {} /* assignment */
| func_invok {}
| unary_op expr {} /* unary operator op */
| expr binary_op expr {}
;

ref_expr: TOK_IDENT {} /* simply a variable name */
;

assign: ref_expr TOK_EQ expr {}
;

func_invok: TOK_IDENT TOK_LPAREN expr_star TOK_RPAREN {}
;

expr_star: /* empty */ {}
| expr_list {}
;

expr_list: expr {}
| expr_list TOK_COMMA expr {}
;

unary_op: TOK_UMINUS {} /* TODO: how to distinguish TOK_MINUS and TOK_UMINUS */
| TOK_NOT {}
| TOK_BITNOT {}
;

binary_op: TOK_PLUS {}
| TOK_MINUS {}
| TOK_MULT {}
| TOK_DIV {}
| TOK_AND {}
| TOK_OR {}
| TOK_GT {}
| TOK_LT {}
| TOK_EQ {}
| TOK_NE {}
| TOK_GE {}
| TOK_LE {}
| TOK_MOD {}
| TOK_BITXOR {}
| TOK_BITAND {}
| TOK_BITOR {}
| TOK_SHL {}
| TOK_SHR {}
;

stmt: TOK_SEMICOLON {} /* empty statement */
| if_stmt {}
| func_invok_stmt {}
| assign_stmt {}
| ret_stmt {}
| compound_stmt {}
;

if_stmt: TOK_IF TOK_LPAREN expr TOK_RPAREN stmt {}
| TOK_IF TOK_LPAREN expr TOK_RPAREN stmt TOK_ELSE stmt {}
;

func_invok_stmt: func_invok TOK_SEMICOLON {}
;

assign_stmt: assign TOK_SEMICOLON {}
;

ret_stmt: TOK_RETURN expr TOK_SEMICOLON {}
;

compound_stmt: TOK_LBRACE stmt_list TOK_RBRACE {} 
| TOK_LBRACE stmt_list TOK_RBRACE TOK_SEMICOLON {} /* compund statement may optionally followed by a semicolon */
;

stmt_list: stmt {}
| stmt_list stmt {}
;

rule_star: event_pattern TOK_ARROW stmt {} /* fill in */
;

event_pattern: primitive_pattern {}
| event_pattern TOK_PAT_OR event_pattern {}
| TOK_PAT_NOT event_pattern {}
| event_pattern TOK_COLON event_pattern {}
| event_pattern TOK_PAT_STAR {}
| TOK_LPAREN event_pattern TOK_RPAREN {}
;

primitive_pattern: TOK_IDENT TOK_LPAREN param_list TOK_RPAREN {}
| TOK_IDENT TOK_LPAREN param_list TOK_RPAREN TOK_BITOR expr {}
;

param_list: TOK_IDENT {} /* TODO not sure whether empty param is allowed or not in event */ 
| param_list TOK_COMMA TOK_IDENT {}
;
%%
